grammar Wikitext
  rule document
    element+ {
      def to_s
        elements.collect{|e| e.to_s}.join
      end
    }
  end
  
  rule element
    heading / paragraph / paragraph_break / list
  end
  
  rule heading
    heading_line
  end
  
  rule heading_line
    start:heading_delimiter+ body:(!heading_end plain_char)* end:heading_end {
      def to_s
        depth = [start.text_value.length, self.end.text_value.chomp.length].min
        tag = "h#{depth}"
        "<#{tag}>#{body.elements.collect{|e| e.plain_char.to_s}.join.strip}</#{tag}>" + self.end.newline_or_eof.text_value
      end
    }
  end
  
  rule heading_end
    heading_delimiter+ newline_or_eof
  end  
  
  rule paragraph
    (!bulleted_list_delimiter formatted_line)+ {
      def to_s
        '<p>' + elements.collect{|e| e.formatted_line.to_s}.join.chomp + '</p>' + elements.last.formatted_line.newline.text_value
      end
    }
  end
  
  rule formatted_line
    !heading_delimiter chunks:(formatted_string+) newline:(newline_or_eof) {
      def to_s
        chunks.elements.collect{|c| c.to_s}.join.strip + newline.text_value
      end
    }
  end
    
  rule formatted_string
    bold_string / italic_string / plain_string
  end
  
  rule bold_string
    start:bold_delimiter body:(italic_string / plain_string)+ end:bold_delimiter {
      def to_s
        '<b>' + body.elements.collect{|e| e.to_s}.join + '</b>'
      end
    }
  end
  
  rule italic_string
    start:italics_delimiter !"'" body:(bold_string / plain_string)+ end:italics_delimiter {
      def to_s
        '<i>' + body.elements.collect{|e| e.to_s}.join + '</i>'
      end
    }
  end
  
  rule plain_string
    (!delimiter plain_char)+ {
      def to_s
        elements.collect{|e| e.plain_char.to_s}.join
      end
    }
  end
  
  rule paragraph_break
    blank_line {
      def to_s
        text_value
      end
    }
  end
  
  rule list
    bulleted_list
  end
  
  rule bulleted_list
    bulleted_list_item+ {
      def to_s
        previous = nil
        indent = '  '
        result = ''
        elements.each do |e|
          if previous.nil?
            # We're on first element
            0.upto(e.depth - 1) do |d|
              result << "\n" + (indent * d) + "<ul>"
            end
          else
            if previous.depth > e.depth
              previous.depth.downto(e.depth + 1) do |d|
                result << "\n" + (indent * (d - 1)) + "</li></ul>"
              end
              result << "\n" + (indent * e.depth) + "</li>"
            elsif previous.depth < e.depth
              previous.depth.upto(e.depth - 1) do |d|
                result << "\n" + (indent * d) + "<ul>"
              end
            else
              result << "\n" + (indent * (e.depth - 1)) + "</li>"
            end
          end
          result << "\n" + e.to_s
          previous = e.clone
        end
        (elements.last.depth - 1).downto(0) do |d|
          result << "\n" + (indent * d) + "</li></ul>\n"
        end
        result
      end
    }
  end
  
  rule bulleted_list_item
    prefix:(bulleted_list_delimiter+) body:(bulleted_list / formatted_line) {
      def to_s
        '<li>' + body.to_s.chomp
      end
      
      def depth
        prefix.text_value.length
      end
    }
  end
  
  rule line
    string newline:newline_or_eof {
      def to_s
        string.to_s + newline.text_value
      end
    }
  end
  
  rule blank_line
    "\n"
  end
  
  rule string
    plain_char+ {
      def to_s
        ERB::Util::h text_value
      end
    }
  end

  rule plain_char
    [^\n] {
      def to_s
        ERB::Util::h text_value
      end
    }
  end
  
  rule newline_or_eof
    ("\n"?)
  end
  
  rule delimiter
    bold_delimiter / italics_delimiter
  end

  rule bold_delimiter
    "'''"
  end
  
  rule italics_delimiter
    "''"
  end
  
  rule heading_delimiter
    '='
  end
  
  rule bulleted_list_delimiter
    '*'
  end
end